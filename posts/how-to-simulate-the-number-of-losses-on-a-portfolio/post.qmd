---
title: "How to Simulate the Number of Losses on a Portfolio?"
date: 2023-11-15
categories: ['Simulations', 'Frequency', 'Trend']
editor_options: 
  chunk_output_type: console
---

In a [previous post](../how-to-simulate-a-portfolio/post.html) we simulated a portfolio
of insurance policies. Today, we simulate its loss count.

We will need the portfolio data frame `policy_df` that we generated back then.
With the below, we re-run that code. The code below will regenerate that
data with the `actuarialRecipes` package:

```{r}
# devtools::install_github("dreanod/actuarialRecipes")
library(actuarialRecipes)

simulated_years <- 2010:2015
initial_policy_count <- 12842
portfolio_growth_rate <- .5 / 100
initial_avg_premium <- 87
rate_changes <- tibble::tibble(
  effective_date = lubridate::dmy(c(
    "04/01/2011", "07/01/2012", "10/01/2013",
    "07/01/2014", "10/01/2015", "01/01/2016"
  )),
  rate_change = c(-5.0, 10.0, 5.0, -2.0, 5.0, 5.0) / 100,
)
premium_trend <- 2 / 100
policy_length <- 6
n_expo_per_policy <- 1

policy_df <- simulate_portfolio(
  sim_years = simulated_years,
  initial_policy_count = initial_policy_count,
  ptf_growth = portfolio_growth_rate,
  n_expo_per_policy = n_expo_per_policy,
  policy_length = policy_length,
  initial_avg_premium = initial_avg_premium,
  premium_trend = premium_trend,
  rate_change_data = rate_changes
)
 policy_df
```

We also need to load these packages from the *tidyverse*:

```{r}
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
```

We can be interested in either bulk simulations of the total number of
losses over a period of time, or in how many losses have been generated
by each policy of the portfolio. We will look at both situations in this
post.

# Choice of Frequency Distribution

I will assume that the loss count for each policy is independent,
Poisson distributed. This implicitly assumes that the timing of losses
is independent[^1]. In other words, the fact that a policy had a loss at a given
time does not change the distribution of future losses (for this policy and for
the rest of the portfolio). This intuitively makes sense and is mostly in
line with real data [^2].

[^1]: This is linked to the memory-free property of the exponential distribution.
  But this is a topic for another post.

[^2]: Well, in many situations the loss distribution is slightly
  "over-dispersed" and one can adjust the Poisson distribution or use
  another one to reflect this. This is again a topic for another post.
  In most cases however, the Poisson distribution is just fine as a first
  approximation.

I will assume that **the frequency distribution for exposures written on January
1, 2010 is 5.87%**. This means that one exposure written at this date will inccur
on average 0.0587 losses in a year. We further assume that the frequency
decreases at an annual rate of 1%.

```{r}
initial_freq <- 0.0587
freq_trend <- -1 / 100
```

# Bulk Simulation

In a bulk simulation we simulate the number of losses for a cohort of exposures
over period of time. In this case, we will look at the number of losses
generated by the policies written in each year.

## Calculation of the Annual Loss Frequencies

The total claim count for a group of policy is Poisson distributed with
frequency the sum of the frequencies of the individual policy exposures.
This is because the claim counts of each exposure is Poisson and independent from
one another. For simplicity, we assume that the frequency is the same for all
exposure written in the same year. As a result, the claim count of any given
policy year is proportional to the number of written exposures.

We therefore calculate the number of written exposure per year:

```{r}
freq_df <- policy_df |>
  group_by(policy_year = year(inception_date)) |>
  summarize(n_written_expo = sum(n_expo))
```

```{r}
#| code-fold: true
#| fig-cap: "Number of Exposures Written per Year"
display_table(freq_df)
```

Now, we can calculate the frequency for exposures written in
each annual cohort. The frequency needs to be trended from the
January 1, 2010 to the average inception date of each cohort:

```{r}
initial_freq_date <- ymd("2010-01-01")

freq_df <- policy_df |>
  group_by(PY = year(inception_date)) |>
  summarize(n_expo = sum(n_expo),
            mean_incept_dt = mean(inception_date),
            trending_period = (initial_freq_date %--% mean_incept_dt) / years(1),
            trending_factor = (1 + freq_trend)^trending_period,
            freq_per_expo = initial_freq * trending_factor,
            total_freq = freq_per_expo * n_expo)
```

```{r}
#| code-fold: true
#| fig-cap: "Calculation of the Annual Aggregate Frequency of Loss"
display_table(freq_df)
```
## Calculation of the Expected Claim Count over the Policy Period

The frequency we calculated is on an annual basis. We therefore have to
divide it by two to have the expected claim count for semi-annual
policies:

```{r}
freq_df <- freq_df |>
  mutate(exp_claim_count = total_freq / 2)
```

```{r}
#| code-fold: true
#| fig-cap: "Calculation of the Annual Aggregate Frequency of Loss"
freq_df |>
  select(PY, total_freq, exp_claim_count) |>
  display_table()
```

## Simulating the Number of Losses

We can now simulate the number of losses for each year:

```{r}
set.seed(100)    # <1>
freq_df <- freq_df |> 
  mutate(loss_count = rpois(n(), lambda = exp_claim_count))
```
1. When doing random simulations, this makes sure that we can reproduce the
   same random outputs every time we run the code.

```{r}
#| code-fold: true
#| fig-cap: "Simulated Loss Count per Policy Year"
freq_df |> 
  select(PY, exp_claim_count, loss_count) |> 
  display_table()
```

## Overview of the Simulated Data

We can compare the expected frequency to the simulated total loss count:

```{r}
#| code-fold: true
#| fig-cap: "Comparing Expected Claim Frequency to Simulated Loss Count"
freq_df |> 
  rename(`Expected Frequency` = exp_claim_count,
         `Simulated Loss Count` = loss_count) |>
  pivot_longer(c("Expected Frequency", "Simulated Loss Count")) |>
  ggplot(aes(PY, value, color = name)) +
  geom_line() + geom_point() +
  ylab("Loss Count") + xlab("Policy Year") +
  labs(color = "")
```

Our simulated loss count is close to the expected frequency. However,
the simulated number goes up and down around the expected frequency
and we cannot discern a downward trend.


This is due to the natural variability of the Poisson distribution. We can show
this by comparing the simulated loss count to the 90% confidence interval of
the distribution:

```{r}
#| fig-cap: "Comparing Simulated Loss Count to Confidence Intervals"
freq_df |>
  mutate(lower_bound = qpois(.05, exp_claim_count), # <1>
         upper_bound = qpois(.95, exp_claim_count)) |> # <1>
  select(PY, exp_claim_count, lower_bound, upper_bound, loss_count) |>
  display_table()
```
1. `qpois` is the quantile function of the Poisson distribution.

We can see from the table that all simulated loss counts fall within
the 90\% confidence interval, which helps us validate our results.

# Policy-per-Policy Simulation

The previous simulation only tells us about the total number of losses
generated in each cohort. However, it does not tell **which policy or exposure
generated which loss**. This is limiting for some applications. For
example, we may want to have the size of losses vary depending on exposure
characteristics. In this case, we need to simulate a loss count per policy.
We see how to do this in the rest of this post:

## Calculate average frequency per Policy

First, we need to calculate the expected frequency of loss for each policy. We
do this by trending the initial frequency from January 1, 2010 to the inception
date of each policy:

```{r}
policy_df <- policy_df |>
  mutate(trend_period = (initial_freq_date %--% inception_date) / years(1),
         trend_factor = (1 + freq_trend)^trend_period,
         frequency = initial_freq * n_expo * trend_factor)
```

```{r}
#| code-fold: true
#| fig-cap: "Frequency Calculation for the First Policy of Each Year"
policy_df |>
  group_by(policy_year = year(inception_date)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(policy_id, inception_date, trend_period, trend_factor, frequency) |>
  display_table()
```

We can check from this table that we do have a -1\% change in frequency
between policies that are written one year apart.

## Calculate the Expected Claim Count per Policy

We need to calculate each policy expected total claim count by restating
the annual frequency for the actual policy duration:

```{r}
policy_df <- policy_df |>
  mutate(policy_duration = (inception_date %--% (expiration_date + days(1))) / years(1),
         exp_claim_count = policy_duration * frequency)
```

```{r}
#| code-fold: true
#| fig-cap: "Frequency Calculation for the First Policy of Each Year"
policy_df |>
  group_by(policy_year = year(inception_date)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  select(policy_id, inception_date, frequency, exp_claim_count) |>
  display_table()
```

## Simulate poisson for each policy

With the expected per-policy frequency, we can simulate the number of actual
losses, assuming independence and a Poisson distribution:

```{r}
set.seed(100)
policy_df <- policy_df |>
  mutate(n_claims = rpois(n(), exp_claim_count)) # <1>
```
1. `rpois` will simulate a Poisson random variable for each row in
   the `policy_df` data frame, with the corresponding frequency
   given by the `frequency` column.

```{r}
#| code-fold: true
#| fig-cap: "Simulated Claim Count for the first Policy of Each Year"
policy_df |>
  select(policy_id, inception_date, exp_claim_count, n_claims) |>
  group_by(policy_year = year(inception_date)) |>
  filter(row_number() == 1) |>
  ungroup() |>
  display_table()
```

As the expected claim count is around 3\% we expect most policies will have
no claim.

## Check results and compare

As a check, we compare these results to the bulk simulations above.
We therefore aggregate the policy table to obtain annual expected
frequencies and simulated claim counts:

```{r}
#| code-fold: true
#| fig-cap: "Simulated Claim Count for the first Policy of Each Year"
summary_df <- policy_df |>
  group_by(PY = year(inception_date)) |>
  summarize(
    total_expected_loss_count = sum(exp_claim_count),
    total_simulated_loss_count = sum(n_claims),
  )

display_table(summary_df)
```
We plot this data against the bulk data to help comparison:

```{r}
#| code-fold: true
#| fig-cap: "Comparing Bulk Annual to Per-Policy Frequency Simulations"
summary_df_per_policy <- summary_df |>
  rename(`Per-Policy Expected` = total_expected_loss_count,
         `Per-Policy Simulated` = total_simulated_loss_count) |>
  pivot_longer(c("Per-Policy Expected", "Per-Policy Simulated"))

summary_df_bulk <- freq_df |> 
  rename(`Bulk Expected` = exp_claim_count,
         `Bulk Simulated` = loss_count) |>
  pivot_longer(c("Bulk Expected", "Bulk Simulated"))

summary_df <- bind_rows(summary_df_bulk, summary_df_per_policy)

summary_df |>
  ggplot(aes(PY, value, color = name)) +
  geom_line() + geom_point() +
  ylab("Loss Count") + xlab("Policy Year") +
  labs(color = "", subtitle = "*Bulk and per-policy expected are overlapping")
```

The bulk and the per-policy expected loss frequencies are very close but not
exactly the same. This is because the policy durations are not exactly half a
year as we assumed in the bulk simulation. In fact, the policy durations can be
slightly shorter or longer depending on the inception date. On average, it is
slightly shorter for the overall portfolio. This results in a lower expected
claim count for the per-policy simulation than for the bulk simulation.

On the other hand, the simulated loss counts are different due to the natural
volatility of the Poisson distribution. We can however verify that the
per-policy simulated loss count is within the 90\% confidence interval we
derived for the bulk simulation.

## The Function That Does it All

The `simulate_loss_count` function from the
[`actuarialRecipes`](https://github.com/dreanod/actuarialRecipes) package
reproduces the per-policy simulation:

```{r}
# devtools::install_github("dreanod/actuarialRecipes")
library(actuarialRecipes)

initial_freq <- 0.0587
initial_freq_date <- lubridate::ymd("2010-01-01")
freq_trend <- -1 / 100

set.seed(100)
loss_count <- simulate_loss_count(
  portfolio = policy_df,
  initial_freq = initial_freq,
  initial_freq_date = initial_freq_date,
  freq_trend = freq_trend
)
```

The returned value `loss_count` is a vector with the number of losses
for each policy in `policy_df`.

# Conclusion

In summary, we have seen too approaches to simulate loss counts for
a portfolio of policies: a bulk approach that simulates claim counts
on annual cohorts of written policies, and a per-policy approach that
simulates the claim count for individual policies. The latter approach
is the most flexible, as it gives us the possibility to simulate a
dataset of individual losses, with claim amount and occurrence date.
We will explore this topic in a future post.

